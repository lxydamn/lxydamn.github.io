[{"title":"基于AOP、MyBatis的通用查询增强","url":"/2025/08/17/cross-query/","content":"Github: https://github.com/lxydamn/zeon/tree/master/bd-enhancer\n\n\n问题场景在大多数业务场景中，表通常会关联多个表，比如用户表和角色表，用户表和权限表等等。在查询用户信息时，如果不在 SQL 中写关联，则会在业务逻辑中编写关联逻辑，随着业务量的增长，实体类不断增多，关联的逻辑也会不断增加，这时候不仅要在业务逻辑中编写这部分关联逻辑，还有业务本身的逻辑，那么代码量就会非常的大。\n举例：\n@Override    public void generateHeaderInfo(List&lt;InvoiceHeader49722&gt; invoiceHeaders) &#123;        // 获取公司        List&lt;String&gt; companyList = invoiceHeaders.stream().map(InvoiceHeader49722::getCompanyCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, FndCompany&gt; longFndCompanyMap = companyRepository.selectMapByCodes(companyList);        // 获取员工        List&lt;String&gt; employeeList = invoiceHeaders.stream().map(InvoiceHeader49722::getEmployeeCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, ExpEmployee&gt; longExpEmployeeMap = expEmployeeRepository.selectMapByIds(employeeList);        // 获取单位        List&lt;String&gt; unitList = invoiceHeaders.stream().map(InvoiceHeader49722::getUnitCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, ExpOrgUnit&gt; longHfbsUnitMap = unitRepository.selectUnitMapByIds(unitList);        // 获取岗位        List&lt;String&gt; postionList = invoiceHeaders.stream().map(InvoiceHeader49722::getPositionCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, ExpOrgPosition&gt; longHfbsPositionMap = positionRepository.selectMapByIds(postionList);        // 获取核算主体        List&lt;String&gt; aeList = invoiceHeaders.stream().map(InvoiceHeader49722::getAccountingEntityCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, GldAccountingEntity&gt; accountingEntityMap = accountingEntityRepository.selectMapByIds(aeList);        // 获取货币        List&lt;String&gt; currencyList = invoiceHeaders.stream().map(InvoiceHeader49722::getCurrencyTypeCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, GldCurrency&gt; longGldCurrencyMap = currencyRepository.selectMapByIds(currencyList);        // 发票类型        List&lt;String&gt; typeList = invoiceHeaders.stream().map(InvoiceHeader49722::getInvoiceTypeCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, AcpMoInvoiceType&gt; longAcpMoInvoiceTypeMap = invoiceTypeRepository.selectMapByIds(typeList);        // 交易方式        List&lt;String&gt; methodList = invoiceHeaders.stream().map(InvoiceHeader49722::getTransactionMethodCode)                .collect(Collectors.toList());        Map&lt;String, CshPaymentMethod&gt; longCshPaymentMethodMap = cshPaymentMethodRepository.selectMapByIds(methodList);        invoiceHeaders.forEach(item -&gt; &#123;            item.setCompanyName(Optional.ofNullable(longFndCompanyMap.get(item.getCompanyCode()))                            .map(FndCompany::getCompanyShortName).orElse(&quot;未知公司&quot;));            item.setEmployeeName(Optional.ofNullable(longExpEmployeeMap.get(item.getEmployeeCode()))                            .map(ExpEmployee::getName).orElse(&quot;未知员工&quot;));            item.setUnitName(Optional.ofNullable(longHfbsUnitMap.get(item.getUnitCode()))                            .map(ExpOrgUnit::getDescription).orElse(&quot;未知单位&quot;));            item.setPositionName(Optional.ofNullable(longHfbsPositionMap.get(item.getPositionCode()))                            .map(ExpOrgPosition::getDescription).orElse(&quot;未知职位&quot;));            item.setAccountingEntityName(Optional.ofNullable(accountingEntityMap.get(item.getAccountingEntityCode()))                            .map(GldAccountingEntity::getAccEntityName).orElse(&quot;未知实体&quot;));            item.setCurrencyType(Optional.ofNullable(longGldCurrencyMap.get(item.getCurrencyTypeCode()))                            .map(GldCurrency::getCurrencyName).orElse(&quot;未知币种&quot;));            item.setInvoiceTypeName(Optional.ofNullable(longAcpMoInvoiceTypeMap.get(item.getInvoiceTypeCode()))                            .map(AcpMoInvoiceType::getDescription).orElse(&quot;未知发票类型&quot;));            item.setTransactionMethod(Optional.ofNullable(longCshPaymentMethodMap.get(item.getTransactionMethodCode()))                            .map(CshPaymentMethod::getDescription).orElse(&quot;未知支付方式&quot;));        &#125;);    &#125;\n\n基本解决思路AOPSpring 中提供了 AOP 切面，AOP(Aspect-Oriented Programming)是面向切面的一种编程思想，其含义是把遍布应用程序的横切关注点（cross-cutting concern）提取出来，并封装成可重用的模块，从而将应用程序的关注点（concern）分离开，AOP 的实现是基于动态代理技术。在 Spring 中，可以使用 @Aspect 注解定义切面，并使用 @Pointcut 注解定义切点，然后使用 @Before、@After、@AfterReturning、@AfterThrowing、@Around 等注解定义通知。\n在上述问题中，需要用到的即是 @AfterReturning 注解，该注解用于定义返回后执行的通知。\nMyBatis 通用查询MyBatis 是一个优秀的持久层框架，它的一个核心优势就是提供了强大的动态 SQL 能力。这使得开发者可以根据不同的条件灵活地构建 SQL 语句\n在这个场景中，只需要使用 @SelectProvider 这个注解，这个注解无需编写 xml，在方法中即可完成动态SQL 的构建\n小结结合 AOP 和 MyBatis 的功能，解决方案的大致框架已经有了，如下：\n\n创建一个切面，在查询方法返回时，拦截返回的数据\n使用 MyBatis 构建动态 SQL，获取需要关联的数据\n将获取的数据赋值到返回的数据中\n\n上述的框架只大致描述了基本过程，但缺少具体的细节，这里进行补充：\n\n创建@CrossQuery注解，该注解用于标注需要进行数据关联的查询方法，作为 AOP 的切点\n创建@CrossQueryField、@CrossQueryEntity 注解，该注解用于标注实体类的外键，属性需要填写关联的属性名称、关联的表名、关联的列名等参数\n通过反射获取上述注解中的参数，并构建动态 SQL，将获取的数据赋值给返回的数据\n\n实现前置条件依赖引入&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;  &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;  &lt;version&gt;2.0.35&lt;/version&gt;&lt;/dependency&gt;\n\n数据库样例create table role(    id          bigint auto_increment        primary key,    role        varchar(10)  null,    role_name   varchar(30)  null,    description varchar(256) null,    constraint role        unique (role));create table users(    id       bigint auto_increment        primary key,    username varchar(100) not null,    password varchar(200) not null,    role     varchar(10)  not null,    nickname varchar(10)  not null);\n\n实体类创建public class Users extends BaseDomain implements Serializable &#123;    private static final long serialVersionUID = 438491303269108393L;    private Long id;    private String username;    private String password;    /** 外键 */    @CrossQueryField(tableName = &quot;role&quot;, keyField = &quot;role&quot;, valueField = &quot;roleName&quot;)    @CrossQueryEntity(keyField = &quot;role&quot;, tableName = &quot;role&quot;, valueField = &quot;roleObj&quot;)    private String role;    private String nickname;    /** 关联查询目标 */    private String roleName;    /** 关联实体类 */    private Role roleObj;‘    ... Getter Setter...&#125;\n\n注解定义/** * &lt;p&gt; *  描述:  跨表查询字段注解 *  AOP 切点 * &lt;/p&gt; */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CrossQuery &#123;&#125;/** * 描述：关联查询实体类注解 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface CrossQueryEntity &#123;    /**     * key字段名     */    String keyField();    /**     * 表名     */    String tableName();    /**     * value字段名，查询目标     */    String valueField();&#125;/** * 关联查询字段注解 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface CrossQueryField &#123;    /**     * Key 字段     */    String keyField();    /**     * key Table 字段     */    String tableKeyField() default &quot;&quot;;    /**     * Value 字段     */    String valueField();    /**     * Value Table 字段     */    String tableValueField() default &quot;&quot;;    /**     * tableName     */    String tableName();&#125;\n\nMapper 定义以及动态 SQL 构建@Mapperpublic interface CommonDbEnhancedMapper &#123;    /**     * 通用K,V型查询     * @param tableName tableName     * @param keyField keyFieldName     * @param valueField valueFieldValue     * @param list 实体列表     * @return list     * @param &lt;T&gt; Entity     */    @SelectProvider(value = CommonProvider.class, method = &quot;selectListUseKeyValue&quot;)    @MapKey(&quot;_xxy&quot;)    &lt;T&gt; Map&lt;Object, JSONObject&gt; selectListUseKeyValue(List&lt;T&gt; list, String tableName, String keyField, String valueField);    /**     * 通用K,V型查询     * @param tableName tableName     * @param keyField keyFieldName     * @param list 实体列表     * @return list     * @param &lt;T&gt; Entity     */    @SelectProvider(value = CommonProvider.class, method = &quot;selectMap&quot;)    @MapKey(&quot;_xxy&quot;)    &lt;T&gt; Map&lt;Object, JSONObject&gt; selectMap(List&lt;T&gt; list, String tableName, String keyField);&#125;/** * SQL 构建类 */public class CommonProvider &#123;    public static &lt;T&gt; String selectListUseKeyValue(List&lt;T&gt; list, String tableName, String keyField, String valueField) &#123;        StringBuilder sql = new StringBuilder();        // Generate keys        String ids = SqlUtils.getIds(list, keyField);        String tableKey = SqlUtils.camelToUnderline(keyField);        String tableValue = SqlUtils.camelToUnderline(valueField);        sql.append(&quot;SELECT &quot;)                .append(tableKey)                .append(&quot; AS _xxy&quot;)                .append(&quot;,&quot;)                .append(tableValue)                .append(&quot; AS value&quot;)                .append(&quot; FROM &quot;)                .append(tableName)                .append(&quot; WHERE &quot;)                .append(keyField)                .append(&quot; IN (&quot;)                .append(ids)                .append(&quot;)&quot;);        return sql.toString();    &#125;    public static &lt;T&gt; String selectMap(List&lt;T&gt; list, String tableName, String keyField) &#123;        StringBuilder sql = new StringBuilder();        String ids = SqlUtils.getIds(list, keyField);        String tableKey = SqlUtils.camelToUnderline(keyField);        sql.append(&quot;SELECT * ,&quot;)                .append(tableKey)                .append(&quot; AS _xxy&quot;)                .append(&quot; FROM &quot;)                .append(tableName)                .append(&quot; WHERE &quot;)                .append(tableKey)                .append(&quot; IN (&quot;)                .append(ids)                .append(&quot;)&quot;);        return sql.toString();    &#125;&#125;/** * SqlUtils 工具类 */public class SqlUtils &#123;    /**     *     * @param list entity&#x27;s list     * @param fieldName entity field name     * @return &quot;v1,v2,v3&quot;     * @param &lt;T&gt; clazz     */    public static &lt;T&gt; String getIds(List&lt;T&gt; list, String fieldName) &#123;        if (CollectionUtils.isEmpty(list)) &#123;            return null;        &#125;        Class&lt;?&gt; clazz = list.get(0).getClass();        Field field = ReflectUtils.getField(clazz, fieldName);        if (field == null) &#123;            return null;        &#125;        field.setAccessible(true);        boolean isString = field.getType().equals(String.class);        String result =  list.stream().map(item -&gt; ReflectionUtils.getField(field, item))                .filter(Objects::nonNull)                .map(item -&gt; String.format(&quot;&#x27;%s&#x27;&quot;, item))                .distinct()                .collect(Collectors.joining(&quot;,&quot;));        if (!StringUtils.hasLength(result)) &#123;            return null;        &#125;        return result;    &#125;    /**     * 驼峰转下划线     * @param camelCaseStr 驼峰字符串     * @return 下划线字符串     */    public static String camelToUnderline(String camelCaseStr) &#123;        if (camelCaseStr == null || camelCaseStr.isEmpty()) &#123;            return camelCaseStr;        &#125;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; camelCaseStr.length(); i++) &#123;            char c = camelCaseStr.charAt(i);            if (Character.isUpperCase(c)) &#123;                // 如果不是第一个字符，前面加下划线                if (i &gt; 0) &#123;                    sb.append(&#x27;_&#x27;);                &#125;                sb.append(Character.toLowerCase(c));            &#125; else &#123;                sb.append(c);            &#125;        &#125;        return sb.toString();    &#125;&#125;\n\n切面实现@Aspect@Componentpublic class CrossQueryAspect &#123;    private static final Logger logger = LoggerFactory.getLogger(CrossQueryAspect.class);    @Resource    private CommonDbEnhancedMapper commonDbEnhancedMapper;    @AfterReturning(value = &quot;@annotation(crossQuery)&quot;, returning = &quot;value&quot;)    public void doAfterReturning(JoinPoint joinPoint, CrossQuery crossQuery, Object value) &#123;        logger.info(&quot;&lt;=== start execute cross query, method &#123;&#125; ====&gt; &quot;, joinPoint.getSignature().getName());        if (value == null) &#123;            logger.info(&quot;return value is null&quot;);            return;        &#125;        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        logger.info(&quot;Signature Return Type: &#123;&#125;&quot;, signature.getReturnType());        List&lt;Object&gt; list = new ArrayList&lt;&gt;();        if (value instanceof BaseDomain || value.getClass().isArray()) &#123;            list.add(value);        &#125; else if (value instanceof List&lt;?&gt;) &#123;            list.addAll((Collection&lt;?&gt;) value);        &#125;        if (CollectionUtils.isEmpty(list)) &#123;            logger.info(&quot;return value is empty&quot;);            return;        &#125;        Class&lt;?&gt; returnClazz = list.get(0).getClass();        Field[] declaredFields = returnClazz.getDeclaredFields();        for (Field declaredField : declaredFields) &#123;            declaredField.setAccessible(true);            CrossQueryField crossQueryField = declaredField.getDeclaredAnnotation(CrossQueryField.class);            CrossQueryEntity crossQueryEntity = declaredField.getDeclaredAnnotation(CrossQueryEntity.class);            if (crossQueryField != null) &#123;                processCrossQuery(crossQueryField, returnClazz, list);            &#125;            if (crossQueryEntity != null) &#123;                processCrossQuery(crossQueryEntity, returnClazz, list);            &#125;        &#125;    &#125;    private void processCrossQuery(CrossQueryEntity queryEntity, Class&lt;?&gt; returnClazz, List&lt;Object&gt; values) &#123;    String keyFieldName = queryEntity.keyField();        String entityFieldName = queryEntity.valueField();        String tableName = queryEntity.tableName();        Field keyField = ReflectUtils.getField(returnClazz, keyFieldName);        Field entityField = ReflectUtils.getField(returnClazz, entityFieldName);        keyField.setAccessible(true);        entityField.setAccessible(true);        Class&lt;?&gt; entityFieldType = entityField.getType();        Map&lt;Object, JSONObject&gt; map = commonDbEnhancedMapper.selectMap(values, tableName, keyFieldName);        for (Object value : values) &#123;            Object key = ReflectionUtils.getField(keyField, value);            JSONObject jsonObject = map.get(key);            Object targetEntity = JSON.parseObject(jsonObject.toJSONString(), entityFieldType, JSONReader.Feature.SupportSmartMatch);            ReflectionUtils.setField(entityField, value, targetEntity);        &#125;    &#125;    private void processCrossQuery(CrossQueryField queryField, Class&lt;?&gt; clazz, List&lt;Object&gt; values) &#123;        String keyFieldName = queryField.keyField();        String valueFieldName = queryField.valueField();        String tableName = queryField.tableName();        if (StringUtils.hasLength(queryField.tableKeyField()))            keyFieldName = queryField.tableKeyField();        if (StringUtils.hasLength(queryField.tableValueField()))            valueFieldName = queryField.tableValueField();        Field keyField = ReflectUtils.getField(clazz, queryField.keyField());        Field valueField = ReflectUtils.getField(clazz, queryField.valueField());        keyField.setAccessible(true);        valueField.setAccessible(true);        Map&lt;Object, JSONObject&gt; map = commonDbEnhancedMapper.selectListUseKeyValue(values, tableName, keyFieldName, valueFieldName);        for (Object object: values) &#123;            Object key = ReflectionUtils.getField(keyField, object);            JSONObject jsonObject = map.get(key);            if (jsonObject != null) &#123;                ReflectionUtils.setField(valueField, object, jsonObject.get(&quot;value&quot;));            &#125;        &#125;    &#125;    private boolean isBaseType(Object value) &#123;        return value.getClass().getClassLoader() == null;    &#125;&#125;\n\n测试使用@CrossQuery建议将 @CrossQuery 放在 Mybatis 的 Mapper 接口方法上，这样在查询完主数据之后，即会进行关联查询，方便后续的业务逻辑处理。\n@Mapperpublic interface UsersDao &#123;    /**     * 通过ID查询单条数据     *     * @param id 主键     * @return 实例对象     */    @CrossQuery    Users queryById(Long id);    /**     * 查询指定行数据     * @param users 实例对象     * @return List&lt;Users&gt;     */    @Select(&quot;select * from users&quot;)    @CrossQuery    List&lt;Users&gt; queryAll(Users users);&#125;  // Controller  @GetMapping  public ResponseEntity&lt;List&lt;Users&gt;&gt; queryAll() &#123;      return ResponseEntity.ok(usersDao.queryAll(null));  &#125;  @GetMapping(&quot;&#123;id&#125;&quot;)  public ResponseEntity&lt;Users&gt; queryById(@PathVariable(&quot;id&quot;) Long id) &#123;      return ResponseEntity.ok(this.usersDao.queryById(id));  &#125;\n\n测试结果\nqueryAll\n\nqueryById\n\n\n总结这篇文章提出了一种使用 AOP（面向切面编程）和 MyBatis 动态 SQL 功能来处理业务应用中跨表查询的解决方案。主要目的是减少处理实体关联时的代码复杂性和重复性。\n核心组件\n@CrossQuery 注解：标记需要跨表数据增强的方法\n@CrossQueryField 注解：定义字段级别的跨查询关系\n@CrossQueryEntity 注解：定义实体级别的跨查询关系\nAOP 切面：拦截带有 @CrossQuery 注解的方法并执行数据增强\n动态 SQL 提供者：使用 MyBatis 的 @SelectProvider 在运行时构建灵活的查询\n基于反射的处理：自动将相关数据映射到目标实体\n\n","categories":["业务增强"],"tags":["AOP","MyBatis"]},{"title":"Seata","url":"/2025/08/15/seata/","content":"Seata简要介绍Seata 是阿里开源的一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。\n分布式系统的理论依据CAP定理这个定理的内容是指，在一个分布式系统中，最多只能满足Consistency(一致性)、Availability(可用性)、Partitiontolerance(分区容错性)三者中的两个。\n\n一致性（C）\n在同一时间访问，数据都相同（等同于所有节点访问同一份最新的数据副本）\n\n可用性（A）\n在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n\n分区容错性（P）\n以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择\n\n\nBASE理论BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE理论的出现是为了通过一定的权衡，放宽了CAP的部分要求，即可满足其要求。每个应用可以根据自身业务特点，对三个条件适当放宽或锁紧来达到目的。\n\n基本可用\n基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性\n\n软状态\n软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时\n\n最终一致性\n最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\n\n\nSEATA的基本架构TC事务协调者；维护全局和分支事务的状态，驱动全局事务提交或回滚\nTM事务管理器；定义全局事务的范围：开始全局事务、提交或回滚全局事务\nRM资源管理器；管理分支事务处理的资源，与TC交互以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚\nTC作为一个server独立运行在服务其中。\n\n事务模式AT模式概述AT 模式是 Seata 创新的一种非侵入式的分布式事务解决方案，Seata 在内部做了对数据库操作的代理层，我们使用 Seata AT 模式时，实际上用的是 Seata 自带的数据源代理 DataSourceProxy，Seata 在这层代理中加入了很多逻辑，比如插入回滚 undo_log 日志，检查全局锁等。\n整体机制通过两个阶段完成事务\n\n阶段一：提交业务数据事务并记录undo log日志，释放本地锁和连接资源\n\n阶段二：直接提交自己的事务，不等待其他事务完成，回滚时通过阶段一的undo log进行反向修改数据\n\n\n基本使用在入口事务上声明注解@GlobalTransactional\nTCC模式SAGA模式XA","tags":["Seata"]},{"title":"SpringWeb请求通用加密组件","url":"/2025/08/22/spring-web-encrypt/","content":"简要介绍该组件是为了对 Web 请求进行统一加解密处理而创建的，在业务场景中，我们往往需要对一些敏感业务数据进行加密处理，比如手机号，身份证号等等，该组件通过自定义参数解析器、增强 Jackson 序列化和反序列化过程来实现对 Web 请求参数的加解密处理。\n通过这种方式可以实现前端无感的加解密处理\n\n\n原理简介spring-web 模块中包含了一系列的 HttpMessageConverter 接口,这些接口通过 InputStream 和 OutputStream 来读写 Http 请求的 Body\n框架提供了具体的实现给主要的媒体类型，比如 application/json，Spring 应用程序作为客户端（请求发送方）时，这些接口会注册到 RestClient 和 RestTemplate 中,作为服务端（请求接收方）时，注册到 RequestMappingHandlerAdapter。\n在 SpringMVC 中，JSON 数据是通过 MappingJackson2HttpMessageConverter 中的 ObjectMapper 来进行序列化和反序列化的\n可以查看官方文档: SpringDocs\nMappingJackson2HttpMessageConverter\nAn HttpMessageConverter implementation that can read and write JSON by using Jackson’s ObjectMapper. You can customize JSON mapping as needed through the use of Jackson’s provided annotations. When you need further control (for cases where custom JSON serializers&#x2F;deserializers need to be provided for specific types), you can inject a custom ObjectMapper through the ObjectMapper property. By default, this converter supports application/json. This requires the com.fasterxml.jackson.core:jackson-databind dependency.\n\n\n如上所述，对于大部分 JSON 格式的数据，也即是 Http Body 携带的数据，可自定义 ObjectMapper 对一些字段序列化&#x2F;反序列化的方式来实现加&#x2F;解密处理了\n至于其他非 Body 的数据，如 RequestParam 参数，在后面会介绍\n代码实现在编写核心代码之前，先定义一个 @Encrypt 注解，用于标识需要加密的字段，之后所有的核心代码都需要这个注解。\n@JacksonAnnotation@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)public @interface Encrypt &#123;    /**     * 密钥     */    String value() default &quot;&quot;;&#125;\n\nHTTP Body配置Jackson这里通过实现 BeanPostProcessor 接口中的 postProcessAfterInitialization 方式，在 Bean 初始化之后，再增强需要的 Bean\npublic class WebBeanPostProcessor implements BeanPostProcessor, PriorityOrdered &#123;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        // 创建加密模块        CryptoModule cryptoModule =                        new CryptoModule(new EncryptBeanSerializerModifier(), new EncryptBeanDeserializerModifier());        // ObjectMapper 注册加密模块        if (bean instanceof ObjectMapper objectMapper) &#123;            logger.info(&quot;ObjectMapper registering cryptoModule&quot;);            objectMapper.registerModule(cryptoModule);        &#125; else if (bean instanceof RequestMappingHandlerAdapter adapter) &#123;            List&lt;HttpMessageConverter&lt;?&gt;&gt; converters = adapter.getMessageConverters();            for (HttpMessageConverter&lt;?&gt; converter : converters) &#123;                if (converter instanceof MappingJackson2HttpMessageConverter messageConverter) &#123;                    // 获取 MappingJackson2HttpMessageConverter 中的ObjectMapper，并注册加密模块                    ObjectMapper objectMapper = messageConverter.getObjectMapper();                    objectMapper.registerModule(cryptoModule);                    logger.info(&quot;MappingJackson2HttpMessageConverter&#x27;s ObjectMapper registering cryptoModule&quot;);                &#125;            &#125;        &#125;        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);    &#125;    @Override    public int getOrder() &#123;        return Integer.MIN_VALUE;    &#125;&#125;ObjectMapper\nObjectMapper 的 readValue 和 writeValue 两个方法可以完成 JSON 字符串和对象的转换，同时 ObjectMapper 通过可插拔的 Module 来灵活的定制序列化&#x2F;反序列的操作。\nCryptoModule继承抽象类 Module 来实现 setupModule(SetupContext setupContext), setupContext 可以添加序列化器\nSerializer &amp; BeanSerializerModifier\nBeanSerializerModifier 可以在 Jackson 创建 Serializer 的生命周期中修改序列化器\n这里不直接添加 Serializer 是为了通过 BeanSerializerModifier 提供的上下文信息来准确的替换 @Encrypt 标记过的字段，也可以在 Serializer 中实现 ContextualSerializer 来获取上下文。\n\n\n这里给出 Serializer 的代码，Deserializer 反序列器同理，只是 BeanDeserializerModifier 使用的是 updateBuilder。\npublic class EncryptJsonSerializer extends JsonSerializer&lt;Object&gt; &#123;    private static final Logger logger = LoggerFactory.getLogger(EncryptJsonSerializer.class);    private final Encrypt encrypt;    public EncryptJsonSerializer(Encrypt encrypt) &#123;        this.encrypt = encrypt;    &#125;    @Override    public void serialize(Object object, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;        if (object == null) &#123;            return;        &#125;        jsonGenerator.writeString(EncryptUtils.encrypt(object, encrypt));    &#125;&#125;public class EncryptBeanSerializerModifier extends BeanSerializerModifier &#123;    private static final Logger logger = LoggerFactory.getLogger(EncryptBeanSerializerModifier.class);    @Override    public List&lt;BeanPropertyWriter&gt; changeProperties(SerializationConfig config, BeanDescription beanDesc,                    List&lt;BeanPropertyWriter&gt; beanProperties) &#123;        for (BeanPropertyWriter writer : beanProperties) &#123;            if (writer.getAnnotation(Encrypt.class) != null) &#123;                writer.assignSerializer(new EncryptJsonSerializer(writer.getAnnotation(Encrypt.class)));            &#125;        &#125;        return beanProperties;    &#125;&#125;\n\nHTTP requestParams在 SpringMVC 调用 @Controller &#x2F; @RestController 时，会在 HandlerMethodArgumentResolver 接口的一系列实现类中找到支持的解析器，再交由支持的解析器解析参数。\nHandlerMethodArgumentResolver 接口主要有两个方法, 和一些实现类，这些实现类又是抽象类。\n详细文档\n\n在 SpringMVC 中大概有 30 多个具体实现类，这里只继承增强两个即可，分别是 RequestParamMethodArgumentResolver、PathVariableMethodArgumentResolver，还是一个需要自己实现一个 HandlerMethodArgumentResolver来解析 @ModelAttribute\n这里只给出核心 resolveName\n@Overrideprotected Object resolveName(@NonNull String name, @NonNull MethodParameter parameter,                @NonNull NativeWebRequest request) throws Exception &#123;    Object result = super.resolveName(name, parameter, request);    Encrypt encrypt = parameter.getParameterAnnotation(Encrypt.class);    Class&lt;?&gt; targetType = parameter.getParameterType();    if (encrypt == null || result == null) &#123;        return result;    &#125;    return EncryptUtils.decrypt(result, encrypt, targetType);&#125;\n\n@ModelAttribute 注解就是将请求中 parameters 解析到实体类中的注解，不添加注解时并且接收参数是非基本类型时默认使用 @ModelAttribute\n所以在实现 supportsParameter 方法时要注意，不仅要实现 ModelAttributeMethodProcessor中的逻辑，而且还要添加上 @Encrypt的判断，并且要添加到 ServletModelAttributeMethodProcessor 的前面，防止接收加密后的字符串后类型转换错误。\n\n\npublic class EncryptModelAttributeResolver implements HandlerMethodArgumentResolver &#123;    private final boolean annotationNotRequired;    public EncryptModelAttributeResolver(boolean annotationNotRequired) &#123;        this.annotationNotRequired = annotationNotRequired;    &#125;    public boolean supportsParameter(MethodParameter parameter) &#123;        return (parameter.hasParameterAnnotation(ModelAttribute.class)                        || this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType()))                        &amp;&amp; parameter.hasMethodAnnotation(Encrypt.class);    &#125;    @Override    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,                    NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;        Class&lt;?&gt; paramType = parameter.getParameterType();        Encrypt encrypt = parameter.getParameterAnnotation(Encrypt.class);        // 1. 如果是 String 或基本类型，直接从请求参数取值并解密        if (String.class.isAssignableFrom(paramType)) &#123;            String value = webRequest.getParameter(parameter.getParameterName());            if (value != null) &#123;                return EncryptUtils.decrypt(value, encrypt);            &#125;            return null;        &#125;        // 2. 如果是数组或集合        if (paramType.isArray()) &#123;            String[] values = webRequest.getParameterValues(parameter.getParameterName());            if (values != null) &#123;                for (int i = 0; i &lt; values.length; i++) &#123;                    values[i] = EncryptUtils.decrypt(values[i], encrypt);                &#125;            &#125;            return values;        &#125;        if (List.class.isAssignableFrom(paramType)) &#123;            String[] values = webRequest.getParameterValues(parameter.getParameterName());            List&lt;String&gt; list = new ArrayList&lt;&gt;();            if (values != null) &#123;                for (String val : values) &#123;                    list.add(EncryptUtils.decrypt(val, encrypt));                &#125;            &#125;            return list;        &#125;        // 3. POJO 对象：先实例化，再绑定参数并解密字段        Object attribute = paramType.getDeclaredConstructor().newInstance();        Field[] fields = paramType.getDeclaredFields();        for (Field field : fields) &#123;            Encrypt fieldEncrypt = field.getAnnotation(Encrypt.class);            field.setAccessible(true);            String fieldName = field.getName();            Class&lt;?&gt; fieldType = field.getType();            String[] paramValues = webRequest.getParameterValues(fieldName);            if (paramValues == null || paramValues.length == 0) &#123;                continue;            &#125;            if (fieldEncrypt == null) &#123;                basicProcess(field, attribute, fieldType, paramValues);            &#125; else &#123;                decryptProcess(field, attribute, fieldEncrypt, fieldType, paramValues);            &#125;        &#125;        return attribute;    &#125;    private void basicProcess(Field field, Object attribute, Class&lt;?&gt; fieldType, String[] paramValues)                    throws IllegalAccessException &#123;        if (ConvertUtils.isBasicType(fieldType)) &#123;            field.set(attribute, ConvertUtils.convertToTargetType(paramValues[0], fieldType));        &#125; else if (field.getType().isArray()) &#123;            field.set(attribute, ConvertUtils.convertArrayToTargetType(paramValues, fieldType));        &#125; else if (List.class.isAssignableFrom(fieldType)) &#123;            List&lt;Object&gt; list = new ArrayList&lt;&gt;();            for (String val : paramValues) &#123;                list.add(ConvertUtils.convertToTargetType(val, fieldType));            &#125;            field.set(attribute, list);        &#125;    &#125;    private void decryptProcess(Field field, Object attribute, Encrypt fieldEncrypt, Class&lt;?&gt; fieldType,                    String[] paramValues) throws IllegalAccessException &#123;        if (ConvertUtils.isBasicType(fieldType)) &#123;            field.set(attribute, EncryptUtils.decrypt(paramValues[0], fieldEncrypt, fieldType));        &#125; else if (field.getType().isArray()) &#123;            Object[] objects = new Object[paramValues.length];            for (int i = 0; i &lt; paramValues.length; i++) &#123;                objects[i] = EncryptUtils.decrypt(paramValues[i], fieldEncrypt, fieldType);            &#125;            field.set(attribute, objects);        &#125; else if (List.class.isAssignableFrom(field.getType())) &#123;            List&lt;Object&gt; list = new ArrayList&lt;&gt;();            for (String val : paramValues) &#123;                list.add(EncryptUtils.decrypt(val, fieldEncrypt, fieldType));            &#125;            field.set(attribute, list);        &#125;    &#125;&#125;\n\n注意注入的顺序，否则可能不生效，而且产生类型转换异常\ntipsSpringMVC 源码中，包路径org.springframework.web.method.support的 HandlerMethodArgumentResolverComposite 管理了 HandlerMethodArgumentResolver 所有实现类，可以通过 Debug 的方式，查看请求调用了具体哪个 Resolver\n\n\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        CryptoModule cryptoModule =                        new CryptoModule(new EncryptBeanSerializerModifier(), new EncryptBeanDeserializerModifier());        if (bean instanceof RequestMappingHandlerAdapter adapter) &#123;            List&lt;HandlerMethodArgumentResolver&gt; resolvers = adapter.getArgumentResolvers();            List&lt;HandlerMethodArgumentResolver&gt; newResolvers = new ArrayList&lt;&gt;(resolvers.size());            for (HandlerMethodArgumentResolver resolver : resolvers) &#123;                if (resolver instanceof RequestParamMethodArgumentResolver) &#123;                    newResolvers.add(new EncryptRequestParamResolver(false));                &#125; else if (resolver instanceof PathVariableMethodArgumentResolver) &#123;                    newResolvers.add(new EncryptPathVariableResolver());                    newResolvers.add(new EncryptModelAttributeResolver(true));                &#125; else &#123;                    newResolvers.add(resolver);                &#125;            &#125;            adapter.setArgumentResolvers(newResolvers);        &#125;        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);    &#125;\n\n使用方式// 1. entitypublic class Users implements Serializable &#123;    private static final long serialVersionUID = 438491303269108393L;    @Encrypt    private Long id;    private String username;    // ...&#125;// 2. Controller// 2.1 PathVariable@GetMapping(&quot;/&#123;id&#125;&quot;)public ResponseEntity&lt;Users&gt; queryById(@PathVariable(&quot;id&quot;) @Encrypt Long id) &#123;    return ResponseEntity.ok(this.usersDao.queryById(id));&#125;// 2.2 ModelAttribute@GetMappingpublic ResponseEntity&lt;List&lt;Users&gt;&gt; queryAll(@Encrypt Users users) &#123;    return ResponseEntity.ok(usersDao.queryAll(null));&#125;// 2.3 RequestParam@GetMappingpublic ResponseEntity&lt;List&lt;Users&gt;&gt; queryAll(@RequestParam @Encrypt String phone) &#123;    return ResponseEntity.ok(usersDao.queryAll(null));&#125;\n","tags":["Spring","加密"]}]