[{"title":"Spring Web 加密组件","url":"/2025/08/21/spring-web-encrypt/","content":"简要介绍本组件主要使用到了 SpringWeb 中 RequestParamMethodArgumentResolver,PathVariableMethodArgumentResolver等参数解析器和自定义Jackson序列化器，对业务对象进行加密&#x2F;解密。该过程完全在后端中完成，可以实现前端无感的数据加密脱敏。\nGithub: https://github.com/lxydamn/zeon/tree/master/zeon-encrypt\n\n\n使用方法\n添加依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;com.psn&lt;/groupId&gt;    &lt;artifactId&gt;zeon-encrypt&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n添加注解\n\n1. 实体类 entity  public class Users implements Serializable &#123;      private static final long serialVersionUID = 438491303269108393L;      @Encrypt      private Long id;      private String username;      @Encrypt      private String password;  &#125;2. 控制器 controller  @GetMapping  public ResponseEntity&lt;List&lt;Users&gt;&gt; queryAll(@Encrypt Users user) &#123;      return ResponseEntity.ok(usersDao.queryAll(null));  &#125;  @GetMapping(&quot;/&#123;id&#125;&quot;)  public ResponseEntity&lt;Users&gt; queryById(@PathVariable(&quot;id&quot;) @Encrypt Long id) &#123;      return ResponseEntity.ok(this.usersDao.queryById(id));  &#125;  @PostMapping  public ResponseEntity&lt;Users&gt; add(@RequestBody Users users) &#123;      return ResponseEntity.ok(this.usersService.insert(users));  &#125;\n\n只需要在实体类和 Controller 中添加@Encrypt注解即可实现对返回值和请求参数进行加密了！\n\n\n原理简介graph LR\nA[客户端发送请求] --> B{请求类型}\nB -->|@RequestParam| C[RequestParam 解析器]\nB -->|@PathVariable| D[PathVariable 解析器]\nB -->|@RequestBody| E[Jackson 反序列化]\nC --> F[参数解密]\nD --> F\nE --> F\nF --> G[业务逻辑处理]\nG --> H[生成响应对象]\nH --> I[Jackson 序列化]\nI --> J[字段加密]\nJ --> K[返回加密响应]\n","categories":["业务增强"],"tags":["Spring","Encrypt"]},{"title":"Seata","url":"/2025/08/15/seata/","content":"Seata简要介绍Seata 是阿里开源的一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。\n分布式系统的理论依据CAP定理这个定理的内容是指，在一个分布式系统中，最多只能满足Consistency(一致性)、Availability(可用性)、Partitiontolerance(分区容错性)三者中的两个。\n\n一致性（C）\n在同一时间访问，数据都相同（等同于所有节点访问同一份最新的数据副本）\n\n可用性（A）\n在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n\n分区容错性（P）\n以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择\n\n\nBASE理论BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE理论的出现是为了通过一定的权衡，放宽了CAP的部分要求，即可满足其要求。每个应用可以根据自身业务特点，对三个条件适当放宽或锁紧来达到目的。\n\n基本可用\n基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性\n\n软状态\n软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时\n\n最终一致性\n最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\n\n\nSEATA的基本架构TC事务协调者；维护全局和分支事务的状态，驱动全局事务提交或回滚\nTM事务管理器；定义全局事务的范围：开始全局事务、提交或回滚全局事务\nRM资源管理器；管理分支事务处理的资源，与TC交互以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚\nTC作为一个server独立运行在服务其中。\n\n事务模式AT模式概述AT 模式是 Seata 创新的一种非侵入式的分布式事务解决方案，Seata 在内部做了对数据库操作的代理层，我们使用 Seata AT 模式时，实际上用的是 Seata 自带的数据源代理 DataSourceProxy，Seata 在这层代理中加入了很多逻辑，比如插入回滚 undo_log 日志，检查全局锁等。\n整体机制通过两个阶段完成事务\n\n阶段一：提交业务数据事务并记录undo log日志，释放本地锁和连接资源\n\n阶段二：直接提交自己的事务，不等待其他事务完成，回滚时通过阶段一的undo log进行反向修改数据\n\n\n基本使用在入口事务上声明注解@GlobalTransactional\nTCC模式SAGA模式XA","tags":["Seata"]},{"title":"基于AOP、MyBatis的通用查询增强","url":"/2025/08/17/cross-query/","content":"Github: https://github.com/lxydamn/zeon/tree/master/bd-enhancer\n\n\n问题场景在大多数业务场景中，表通常会关联多个表，比如用户表和角色表，用户表和权限表等等。在查询用户信息时，如果不在 SQL 中写关联，则会在业务逻辑中编写关联逻辑，随着业务量的增长，实体类不断增多，关联的逻辑也会不断增加，这时候不仅要在业务逻辑中编写这部分关联逻辑，还有业务本身的逻辑，那么代码量就会非常的大。\n举例：\n@Override    public void generateHeaderInfo(List&lt;InvoiceHeader49722&gt; invoiceHeaders) &#123;        // 获取公司        List&lt;String&gt; companyList = invoiceHeaders.stream().map(InvoiceHeader49722::getCompanyCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, FndCompany&gt; longFndCompanyMap = companyRepository.selectMapByCodes(companyList);        // 获取员工        List&lt;String&gt; employeeList = invoiceHeaders.stream().map(InvoiceHeader49722::getEmployeeCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, ExpEmployee&gt; longExpEmployeeMap = expEmployeeRepository.selectMapByIds(employeeList);        // 获取单位        List&lt;String&gt; unitList = invoiceHeaders.stream().map(InvoiceHeader49722::getUnitCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, ExpOrgUnit&gt; longHfbsUnitMap = unitRepository.selectUnitMapByIds(unitList);        // 获取岗位        List&lt;String&gt; postionList = invoiceHeaders.stream().map(InvoiceHeader49722::getPositionCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, ExpOrgPosition&gt; longHfbsPositionMap = positionRepository.selectMapByIds(postionList);        // 获取核算主体        List&lt;String&gt; aeList = invoiceHeaders.stream().map(InvoiceHeader49722::getAccountingEntityCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, GldAccountingEntity&gt; accountingEntityMap = accountingEntityRepository.selectMapByIds(aeList);        // 获取货币        List&lt;String&gt; currencyList = invoiceHeaders.stream().map(InvoiceHeader49722::getCurrencyTypeCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, GldCurrency&gt; longGldCurrencyMap = currencyRepository.selectMapByIds(currencyList);        // 发票类型        List&lt;String&gt; typeList = invoiceHeaders.stream().map(InvoiceHeader49722::getInvoiceTypeCode)                        .distinct().collect(Collectors.toList());        Map&lt;String, AcpMoInvoiceType&gt; longAcpMoInvoiceTypeMap = invoiceTypeRepository.selectMapByIds(typeList);        // 交易方式        List&lt;String&gt; methodList = invoiceHeaders.stream().map(InvoiceHeader49722::getTransactionMethodCode)                .collect(Collectors.toList());        Map&lt;String, CshPaymentMethod&gt; longCshPaymentMethodMap = cshPaymentMethodRepository.selectMapByIds(methodList);        invoiceHeaders.forEach(item -&gt; &#123;            item.setCompanyName(Optional.ofNullable(longFndCompanyMap.get(item.getCompanyCode()))                            .map(FndCompany::getCompanyShortName).orElse(&quot;未知公司&quot;));            item.setEmployeeName(Optional.ofNullable(longExpEmployeeMap.get(item.getEmployeeCode()))                            .map(ExpEmployee::getName).orElse(&quot;未知员工&quot;));            item.setUnitName(Optional.ofNullable(longHfbsUnitMap.get(item.getUnitCode()))                            .map(ExpOrgUnit::getDescription).orElse(&quot;未知单位&quot;));            item.setPositionName(Optional.ofNullable(longHfbsPositionMap.get(item.getPositionCode()))                            .map(ExpOrgPosition::getDescription).orElse(&quot;未知职位&quot;));            item.setAccountingEntityName(Optional.ofNullable(accountingEntityMap.get(item.getAccountingEntityCode()))                            .map(GldAccountingEntity::getAccEntityName).orElse(&quot;未知实体&quot;));            item.setCurrencyType(Optional.ofNullable(longGldCurrencyMap.get(item.getCurrencyTypeCode()))                            .map(GldCurrency::getCurrencyName).orElse(&quot;未知币种&quot;));            item.setInvoiceTypeName(Optional.ofNullable(longAcpMoInvoiceTypeMap.get(item.getInvoiceTypeCode()))                            .map(AcpMoInvoiceType::getDescription).orElse(&quot;未知发票类型&quot;));            item.setTransactionMethod(Optional.ofNullable(longCshPaymentMethodMap.get(item.getTransactionMethodCode()))                            .map(CshPaymentMethod::getDescription).orElse(&quot;未知支付方式&quot;));        &#125;);    &#125;\n\n基本解决思路AOPSpring 中提供了 AOP 切面，AOP(Aspect-Oriented Programming)是面向切面的一种编程思想，其含义是把遍布应用程序的横切关注点（cross-cutting concern）提取出来，并封装成可重用的模块，从而将应用程序的关注点（concern）分离开，AOP 的实现是基于动态代理技术。在 Spring 中，可以使用 @Aspect 注解定义切面，并使用 @Pointcut 注解定义切点，然后使用 @Before、@After、@AfterReturning、@AfterThrowing、@Around 等注解定义通知。\n在上述问题中，需要用到的即是 @AfterReturning 注解，该注解用于定义返回后执行的通知。\nMyBatis 通用查询MyBatis 是一个优秀的持久层框架，它的一个核心优势就是提供了强大的动态 SQL 能力。这使得开发者可以根据不同的条件灵活地构建 SQL 语句\n在这个场景中，只需要使用 @SelectProvider 这个注解，这个注解无需编写 xml，在方法中即可完成动态SQL 的构建\n小结结合 AOP 和 MyBatis 的功能，解决方案的大致框架已经有了，如下：\n\n创建一个切面，在查询方法返回时，拦截返回的数据\n使用 MyBatis 构建动态 SQL，获取需要关联的数据\n将获取的数据赋值到返回的数据中\n\n上述的框架只大致描述了基本过程，但缺少具体的细节，这里进行补充：\n\n创建@CrossQuery注解，该注解用于标注需要进行数据关联的查询方法，作为 AOP 的切点\n创建@CrossQueryField、@CrossQueryEntity 注解，该注解用于标注实体类的外键，属性需要填写关联的属性名称、关联的表名、关联的列名等参数\n通过反射获取上述注解中的参数，并构建动态 SQL，将获取的数据赋值给返回的数据\n\n实现前置条件依赖引入&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;  &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;  &lt;version&gt;2.0.35&lt;/version&gt;&lt;/dependency&gt;\n\n数据库样例create table role(    id          bigint auto_increment        primary key,    role        varchar(10)  null,    role_name   varchar(30)  null,    description varchar(256) null,    constraint role        unique (role));create table users(    id       bigint auto_increment        primary key,    username varchar(100) not null,    password varchar(200) not null,    role     varchar(10)  not null,    nickname varchar(10)  not null);\n\n实体类创建public class Users extends BaseDomain implements Serializable &#123;    private static final long serialVersionUID = 438491303269108393L;    private Long id;    private String username;    private String password;    /** 外键 */    @CrossQueryField(tableName = &quot;role&quot;, keyField = &quot;role&quot;, valueField = &quot;roleName&quot;)    @CrossQueryEntity(keyField = &quot;role&quot;, tableName = &quot;role&quot;, valueField = &quot;roleObj&quot;)    private String role;    private String nickname;    /** 关联查询目标 */    private String roleName;    /** 关联实体类 */    private Role roleObj;‘    ... Getter Setter...&#125;\n\n注解定义/** * &lt;p&gt; *  描述:  跨表查询字段注解 *  AOP 切点 * &lt;/p&gt; */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CrossQuery &#123;&#125;/** * 描述：关联查询实体类注解 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface CrossQueryEntity &#123;    /**     * key字段名     */    String keyField();    /**     * 表名     */    String tableName();    /**     * value字段名，查询目标     */    String valueField();&#125;/** * 关联查询字段注解 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface CrossQueryField &#123;    /**     * Key 字段     */    String keyField();    /**     * key Table 字段     */    String tableKeyField() default &quot;&quot;;    /**     * Value 字段     */    String valueField();    /**     * Value Table 字段     */    String tableValueField() default &quot;&quot;;    /**     * tableName     */    String tableName();&#125;\n\nMapper 定义以及动态 SQL 构建@Mapperpublic interface CommonDbEnhancedMapper &#123;    /**     * 通用K,V型查询     * @param tableName tableName     * @param keyField keyFieldName     * @param valueField valueFieldValue     * @param list 实体列表     * @return list     * @param &lt;T&gt; Entity     */    @SelectProvider(value = CommonProvider.class, method = &quot;selectListUseKeyValue&quot;)    @MapKey(&quot;_xxy&quot;)    &lt;T&gt; Map&lt;Object, JSONObject&gt; selectListUseKeyValue(List&lt;T&gt; list, String tableName, String keyField, String valueField);    /**     * 通用K,V型查询     * @param tableName tableName     * @param keyField keyFieldName     * @param list 实体列表     * @return list     * @param &lt;T&gt; Entity     */    @SelectProvider(value = CommonProvider.class, method = &quot;selectMap&quot;)    @MapKey(&quot;_xxy&quot;)    &lt;T&gt; Map&lt;Object, JSONObject&gt; selectMap(List&lt;T&gt; list, String tableName, String keyField);&#125;/** * SQL 构建类 */public class CommonProvider &#123;    public static &lt;T&gt; String selectListUseKeyValue(List&lt;T&gt; list, String tableName, String keyField, String valueField) &#123;        StringBuilder sql = new StringBuilder();        // Generate keys        String ids = SqlUtils.getIds(list, keyField);        String tableKey = SqlUtils.camelToUnderline(keyField);        String tableValue = SqlUtils.camelToUnderline(valueField);        sql.append(&quot;SELECT &quot;)                .append(tableKey)                .append(&quot; AS _xxy&quot;)                .append(&quot;,&quot;)                .append(tableValue)                .append(&quot; AS value&quot;)                .append(&quot; FROM &quot;)                .append(tableName)                .append(&quot; WHERE &quot;)                .append(keyField)                .append(&quot; IN (&quot;)                .append(ids)                .append(&quot;)&quot;);        return sql.toString();    &#125;    public static &lt;T&gt; String selectMap(List&lt;T&gt; list, String tableName, String keyField) &#123;        StringBuilder sql = new StringBuilder();        String ids = SqlUtils.getIds(list, keyField);        String tableKey = SqlUtils.camelToUnderline(keyField);        sql.append(&quot;SELECT * ,&quot;)                .append(tableKey)                .append(&quot; AS _xxy&quot;)                .append(&quot; FROM &quot;)                .append(tableName)                .append(&quot; WHERE &quot;)                .append(tableKey)                .append(&quot; IN (&quot;)                .append(ids)                .append(&quot;)&quot;);        return sql.toString();    &#125;&#125;/** * SqlUtils 工具类 */public class SqlUtils &#123;    /**     *     * @param list entity&#x27;s list     * @param fieldName entity field name     * @return &quot;v1,v2,v3&quot;     * @param &lt;T&gt; clazz     */    public static &lt;T&gt; String getIds(List&lt;T&gt; list, String fieldName) &#123;        if (CollectionUtils.isEmpty(list)) &#123;            return null;        &#125;        Class&lt;?&gt; clazz = list.get(0).getClass();        Field field = ReflectUtils.getField(clazz, fieldName);        if (field == null) &#123;            return null;        &#125;        field.setAccessible(true);        boolean isString = field.getType().equals(String.class);        String result =  list.stream().map(item -&gt; ReflectionUtils.getField(field, item))                .filter(Objects::nonNull)                .map(item -&gt; String.format(&quot;&#x27;%s&#x27;&quot;, item))                .distinct()                .collect(Collectors.joining(&quot;,&quot;));        if (!StringUtils.hasLength(result)) &#123;            return null;        &#125;        return result;    &#125;    /**     * 驼峰转下划线     * @param camelCaseStr 驼峰字符串     * @return 下划线字符串     */    public static String camelToUnderline(String camelCaseStr) &#123;        if (camelCaseStr == null || camelCaseStr.isEmpty()) &#123;            return camelCaseStr;        &#125;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; camelCaseStr.length(); i++) &#123;            char c = camelCaseStr.charAt(i);            if (Character.isUpperCase(c)) &#123;                // 如果不是第一个字符，前面加下划线                if (i &gt; 0) &#123;                    sb.append(&#x27;_&#x27;);                &#125;                sb.append(Character.toLowerCase(c));            &#125; else &#123;                sb.append(c);            &#125;        &#125;        return sb.toString();    &#125;&#125;\n\n切面实现@Aspect@Componentpublic class CrossQueryAspect &#123;    private static final Logger logger = LoggerFactory.getLogger(CrossQueryAspect.class);    @Resource    private CommonDbEnhancedMapper commonDbEnhancedMapper;    @AfterReturning(value = &quot;@annotation(crossQuery)&quot;, returning = &quot;value&quot;)    public void doAfterReturning(JoinPoint joinPoint, CrossQuery crossQuery, Object value) &#123;        logger.info(&quot;&lt;=== start execute cross query, method &#123;&#125; ====&gt; &quot;, joinPoint.getSignature().getName());        if (value == null) &#123;            logger.info(&quot;return value is null&quot;);            return;        &#125;        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        logger.info(&quot;Signature Return Type: &#123;&#125;&quot;, signature.getReturnType());        List&lt;Object&gt; list = new ArrayList&lt;&gt;();        if (value instanceof BaseDomain || value.getClass().isArray()) &#123;            list.add(value);        &#125; else if (value instanceof List&lt;?&gt;) &#123;            list.addAll((Collection&lt;?&gt;) value);        &#125;        if (CollectionUtils.isEmpty(list)) &#123;            logger.info(&quot;return value is empty&quot;);            return;        &#125;        Class&lt;?&gt; returnClazz = list.get(0).getClass();        Field[] declaredFields = returnClazz.getDeclaredFields();        for (Field declaredField : declaredFields) &#123;            declaredField.setAccessible(true);            CrossQueryField crossQueryField = declaredField.getDeclaredAnnotation(CrossQueryField.class);            CrossQueryEntity crossQueryEntity = declaredField.getDeclaredAnnotation(CrossQueryEntity.class);            if (crossQueryField != null) &#123;                processCrossQuery(crossQueryField, returnClazz, list);            &#125;            if (crossQueryEntity != null) &#123;                processCrossQuery(crossQueryEntity, returnClazz, list);            &#125;        &#125;    &#125;    private void processCrossQuery(CrossQueryEntity queryEntity, Class&lt;?&gt; returnClazz, List&lt;Object&gt; values) &#123;    String keyFieldName = queryEntity.keyField();        String entityFieldName = queryEntity.valueField();        String tableName = queryEntity.tableName();        Field keyField = ReflectUtils.getField(returnClazz, keyFieldName);        Field entityField = ReflectUtils.getField(returnClazz, entityFieldName);        keyField.setAccessible(true);        entityField.setAccessible(true);        Class&lt;?&gt; entityFieldType = entityField.getType();        Map&lt;Object, JSONObject&gt; map = commonDbEnhancedMapper.selectMap(values, tableName, keyFieldName);        for (Object value : values) &#123;            Object key = ReflectionUtils.getField(keyField, value);            JSONObject jsonObject = map.get(key);            Object targetEntity = JSON.parseObject(jsonObject.toJSONString(), entityFieldType, JSONReader.Feature.SupportSmartMatch);            ReflectionUtils.setField(entityField, value, targetEntity);        &#125;    &#125;    private void processCrossQuery(CrossQueryField queryField, Class&lt;?&gt; clazz, List&lt;Object&gt; values) &#123;        String keyFieldName = queryField.keyField();        String valueFieldName = queryField.valueField();        String tableName = queryField.tableName();        if (StringUtils.hasLength(queryField.tableKeyField()))            keyFieldName = queryField.tableKeyField();        if (StringUtils.hasLength(queryField.tableValueField()))            valueFieldName = queryField.tableValueField();        Field keyField = ReflectUtils.getField(clazz, queryField.keyField());        Field valueField = ReflectUtils.getField(clazz, queryField.valueField());        keyField.setAccessible(true);        valueField.setAccessible(true);        Map&lt;Object, JSONObject&gt; map = commonDbEnhancedMapper.selectListUseKeyValue(values, tableName, keyFieldName, valueFieldName);        for (Object object: values) &#123;            Object key = ReflectionUtils.getField(keyField, object);            JSONObject jsonObject = map.get(key);            if (jsonObject != null) &#123;                ReflectionUtils.setField(valueField, object, jsonObject.get(&quot;value&quot;));            &#125;        &#125;    &#125;    private boolean isBaseType(Object value) &#123;        return value.getClass().getClassLoader() == null;    &#125;&#125;\n\n测试使用@CrossQuery建议将 @CrossQuery 放在 Mybatis 的 Mapper 接口方法上，这样在查询完主数据之后，即会进行关联查询，方便后续的业务逻辑处理。\n@Mapperpublic interface UsersDao &#123;    /**     * 通过ID查询单条数据     *     * @param id 主键     * @return 实例对象     */    @CrossQuery    Users queryById(Long id);    /**     * 查询指定行数据     * @param users 实例对象     * @return List&lt;Users&gt;     */    @Select(&quot;select * from users&quot;)    @CrossQuery    List&lt;Users&gt; queryAll(Users users);&#125;  // Controller  @GetMapping  public ResponseEntity&lt;List&lt;Users&gt;&gt; queryAll() &#123;      return ResponseEntity.ok(usersDao.queryAll(null));  &#125;  @GetMapping(&quot;&#123;id&#125;&quot;)  public ResponseEntity&lt;Users&gt; queryById(@PathVariable(&quot;id&quot;) Long id) &#123;      return ResponseEntity.ok(this.usersDao.queryById(id));  &#125;\n\n测试结果\nqueryAll\n\nqueryById\n\n\n总结这篇文章提出了一种使用 AOP（面向切面编程）和 MyBatis 动态 SQL 功能来处理业务应用中跨表查询的解决方案。主要目的是减少处理实体关联时的代码复杂性和重复性。\n核心组件\n@CrossQuery 注解：标记需要跨表数据增强的方法\n@CrossQueryField 注解：定义字段级别的跨查询关系\n@CrossQueryEntity 注解：定义实体级别的跨查询关系\nAOP 切面：拦截带有 @CrossQuery 注解的方法并执行数据增强\n动态 SQL 提供者：使用 MyBatis 的 @SelectProvider 在运行时构建灵活的查询\n基于反射的处理：自动将相关数据映射到目标实体\n\n","categories":["业务增强"],"tags":["AOP","MyBatis"]}]